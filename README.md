# Unique-IP-counter
Данная небольшая программка решает нижеизложенную задачу. Предполагается, что будет 2 варианта алгоритма, с небольшими 
отличиями в "работе с памятью". 

### Задача:
Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:

```
145.67.23.4
8.34.5.23
89.54.3.124
89.54.3.124
3.45.71.5
...
```
Файл в размере не ограничен и может занимать десятки и сотни гигабайт.

Необходимо посчитать количество уникальных адресов в этом файле, затратив как можно меньше памяти и времени. 
Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в HashSet), 
желательно чтобы ваша реализация была лучше этого простого, наивного алгоритма.

### Что имеем?
На первый взгляд, задача не очень сложная. Нам нужно завести некий "список". Далее читать из файла строки 
по одной, и сверяться со "списком". Если адреса в списке ещё нет - то добавлять адрес в список. А когда файл 
закончится - просто посчитать в нашем "списке" количество записей. Это и будет ответ. Проблемы начинаются от 
того, что количество уникальных IPv4-адресов равно 256 х 256 х 256 х 256 = 4.294.967.296 штук. Так как 
1 IPv4-адрес это 4 байта, то просто набор байт всех IP-адресов, без точек-разделителей, переносов каретки и пр.
будет занимать 4.294.967.296 х 4 = 17.179.869.184 байта, т.е. 16 гигабайт. А при условии, что файл на входе 
может быть сотни гигабайт - то есть ненулевая вероятность того, что в нём будут все возможные IP-адреса.
И нам, в нашем "списке" для уникальных адресов, в итоге придётся хранить их все. Плюс ко всему, по этому 
"списку" каждый раз нужно будет как-то итерироваться, дабы узнать, есть ли уже там адрес или нет.

### Как же решить такую задачу, затратив как можно меньше памяти и времени? 
Кстати об упомянутом в задаче "наивном" алгоритме решения: Как я понял (возможно я не прав, это теоретические 
рассуждения), называется этот алгоритм "наивным" потому, что должно быть довольно много коллизий, т.к: 
1.  Метод hashCode() у класса String реализован так, что у строк со всеми вариантами IP-адресов, в некоторых 
случаях будут совпадать хэш-коды. Т.к. Произойдет неоднократное переполнение значения примитива int, 
возвращаемого данным методом. Даже если строки будут приходить без точек-разделителей (просто строки с числами). 
Более того, переполнение происходило бы даже если бы hashCode() возвращал long (опять же, даже в случае со 
строками без точек), но уже не так часто, как у int.
2.  К тому же, каждая такая строка с адресом весила бы несравненно больше четырёх байт. Но об этом потом.
3.  HashSet в java основан на HashMap. А HashMap в свою очередь имеет внутри себя массив Node<K,V>[] table, 
в котором лежат корзины со связанными списками ключей и значений. Так вот, максимальный размер в этой таблице, 
который можно указать при инициализации, равен половине максимально значения типа int, т.е. 1.073.741.824. 
Даже если эта таблица будет увеличиваться в размерах, по мере поступления новых значений, то она все равно не 
превысит максимального значения типа int 2.147.483.647. Т.к. в java максимально допустимый размер у массива 
может быть Integer.MAX_VALUE - 8. А это в 2 раза меньше всех возможных значений IP-адресов.

Ещё один простой вариант - завести на диске второй текстовый файл и записывать уникальные адреса в него. 
Памяти (оперативной) так мы на него не тратим, но тогда нам каждый раз нужно будет проходиться по нему поиском, 
как и говорилось выше. Значит нужно думать над своим типом хранилища.  

### Размышления
Сейчас не касательно java. Если внимательно посмотреть на отсортированный список всех возможных IP-адресов, то 
можно заметить, что в нём будет очень много дублирующейся информации. Например, вариантов первого октета у всех 
4-х миллиардов адресов всего 256. Следовательно, для оптимального хранения адресов можно их сортировать и 
избавляться от таких дублей. Мне пришло в голову реализовать своего рода "дерево", в котором количество уровней 
будет равно количеству октетов в IP-адресе, в нашем случае 4. Корнем дерева будет одномерный массив размером 256 
ячеек(первый октет). В данный массив складываются ссылки на такие же массивы по 256 ячеек каждый (второй октет). 
И так 4 раза. В массивах последнего, четвёртого уровня, для экономии памяти лежат примитивы boolean. 
Постарался изобразить схематически:    

```
                                               массив значений
                           массив значений   / третьего октета
                         / второго октета   /   | 0 |-->null
                        /  | 0 |-->null    /    | 1 |-->null
                       /   | 1 |----------/     | 2 |--------------- массив значений
                      /    | 2 |-->null         | 3 |-->null         четвёртого октета
                     /     | 3 |-->null         |...|                 | 0 |-->true      
       корневой     /      |...|                |255|-->null          | 1 |-->false
       массив      /       |255|-->null      номер ячейки             | 2 |-->false
        | 0 |-----      номер ячейки         соответствует            | 3 |-->true
        | 1 |-->null    соответствует        значению                 |...|
        | 2 |-------\   значению             второго октета           |255|-->true
        | 3 |-->null \  второго октета                              номер ячейки
        |...|         \                                             соответствует
        |255|-->null   \                                            значению
       номер ячейки     | 0 |-->null                                четвёртого октета
       соответствует    | 1 |--------....                           
       значению         |...|
       первого октета   |255|-->null             
```

Допустим у нас есть пустое хранилище. Корневой массив пуст. При записи нового адреса, например 0.1.2.2, в такое 
хранилище происходит следующее:
1. Т.к. у нашего адреса значение первого октета равно нулю, то в ячейку №0 корневого массива помещаем новый массив, 
и "переходим" в него. Так мы записали значение первого октета адреса 0.1.2.3.
2. Значение второго октета равно единице - значит в нашем втором массиве мы ищем ячейку №1. Помещаем в неё следующий 
массив и "переходим" в него. Так мы записали значение второго октета.
3. Далее по аналогии, в следующем массиве мы занимаем ячейку №2. Переходим дальше.
4. И в последнем, четвёртом, массиве мы ставим значение true в ячейке №3.

Разумеется перед добавлением в ячейку массива необходимо сначала проверить пустая ли она. А в случае с последним 
массивом, если в нужной нам ячейке уже стоит true - то это значит, что такой адрес в хранилище уже есть. Если удалось
записать новый адрес в хранилище - то мы инкрементируем счётчик этого хранилища. Его конечное значение, как раз
и будет ответом на поставленную задачу.
Исходя из этого, на схеме выше, в хранилище уже хранятся IP-адреса:
0.1.2.0; 0.1.2.3; 0.1.2.255 и адрес/адреса начинающиеся на 2.1....

Таким образом мы избавляемся от дублей. В худшем случае у нас будет 1 экземпляр корневого массива, 
1 х 256 = 256 экземпляров массивов второго уровня, 256 х 256 = 65.536 экземпляров массивов третьего уровня, и
65.536 х 256 = 16.777.216 экземпляров массивов четвертого уровня. Итого 1 + 256 + 65.536 + 16.777.216 = 16.843.009 
массивов, из которых массивы 1-3 уровней содержат ссылки на объекты(массивы), а массивы 4-го уровня, которых больше 
всего, содержат булевы значения. Итого, чуть меньше 17-ти миллионов массивов против 4-х с "копейками" миллиардов 
строк. И проход по такому хранилищу тоже довольно быстр. Нужно всего 4 раза обратиться к ячейке массива. Вроде бы 
не плохо. 

### Память
Теперь давайте поговорим о расходах памяти. Сколько места в памяти будет занимать экземпляр String с IP-адресом? 
Возьмём строку "192.168.0.1". Исходя из того, что я смог найти в сети, провел нижеследующие расчеты (на 100-процентную 
точность я не претендую). В подробности вдаваться не буду. Все расчеты для 64-х разрядной системы, так как, думаю, 
что в конце 2019 года уже маловероятно встретить 32-х разрядную. Итак:

```
new String()
Заголовок: 16 байт
Поле int: 4 байта
Ссылочная переменная на объект массива: 8 байт
Выравнивание для кратности 8-ми : 4 байта
Итого: 32 байта

new char[11]
Заголовок: 16 байт + 4 байта на длину массива = 20 байт
Примитивы char: 2 байта х 11 = 22 байта
Выравнивание для кратности 8-ми : 6 байт
Итого: 48 байт 

Итого, new String("192.168.0.1") = 32 + 48 = 80 байт
```  

Заметим, что строка с IP-адресом может содержать не 11, а 15 символов. Считаем максимальное количество памяти, которое
может понадобиться для хранения строк со всеми возможными адресами: 4.294.967.296 х 80 = 343.597.383.680 байт. 
Т.е. 320 гигабайт. Как-то ну очень много (к слову о "наивном" алгоритме). Надеюсь я всё правильно посчитал. На сколько 
я знаю - JVM умеет некоторым образом оптимизировать память, кэшируя повторяющиеся экземпляры классов (если я ничего 
не путаю). Теперь давайте посчитаем, сколько в худшем случае будет занимать наше хранилище:

 ```
Массив 1-3 уровня
Заголовок: 16 байт + 4 байта на длину массива = 20 байт
Ссылочные переменные на объекты массивов: 8 байт х 256 : 2048 байт
Выравнивание для кратности 8-ми : 4 байт
Итого: 2072 байта
 
Массив 4-го уровня
Заголовок: 16 байт + 4 байта на длину массива = 20 байт
Ссылочные переменные на объекты массивов: 1 байт х 256 : 256 байт
Выравнивание для кратности 8-ми : 4 байт
Итого: 280 байт
 ```

Вот здесь очень интересно, т.к. я нигде не нашёл однозначного ответа на вопрос, сколько памяти занимают примитивы 
boolean в массивах. Как я понял всё зависит от конкретной реализации JVM. От 1 бита до 1 байта. В своих расчетах я 
исходил из 1 байта на boolean в массиве. С примитивами в Java вообще все не так просто. Если примитивы boolean, 
byte, short и char являются полями класса - то на них выделяется по 4 байта, как на int, а если же они хранятся в 
массивах то выделяется от 1 бита до 1 байта, 1 байт, 2 байта и 2 байта соответственно. Итак, максимальное количество
памяти для массивов 1-3 уровней у нас в хранилище (1 + 256 + 65.536) х 2072 = 136.323.096 байта, т.е. 130 мегабайт. 
И массивы 4-го уровня 16.777.216 х 280 = 4.697.620.480 байт, т.е. 4,375 гигабайта. Итого 136.323.096 + 4.697.620.480 =
4.833.943.576 байт, т.е. 4,5 гигабайт. Это гораздо меньше 16 гигабайт в случае хранения просто IP-адресов как они есть, 
и уж тем более меньше 320 гигабайт в случае хранения строк. Но мы же не будем останавливаться на достигнутом?

### Реализованный алгоритм
При передаче в хранилище адресов с одинаковыми 3-мя первыми октетами (адреса одной сети), может случиться так, что 
все значения массива четвёртого уровня примут значение true, т.е. в хранилище придут все адреса данной сети, т.е. 
данный массив полностью заполнится. И если бы этот массив "знал", что он уже полон - то следующие входящие адреса он
бы просто не пускал. Тоже самое и с массивами других уровней. Если массив 3-го уровня будет знать, что все его массивы 
4-го уже заполнены то... и т.д. Следовательно, каждый массив необходимо обернуть в класс, который будет контролировать 
заполненность и не пускать новые адреса. Да, это дополнительные накладные расходы и на память, и на вычесления, но при 
этом можно как бы "схлопывать" заполнившиеся ветви нашего "дерева", ведь заполненный массив можно смело удалять, 
присвоив ссылке на этот массив значение null, а дальше GC его заберёт. К тому же, java не позволит создавать такие
массивы по очереди. Нужно будет сразу инициализировать многомерный массив. И в случае, если на вход придёт файл, в
котором всего 10 строк, то мы впустую потратим 4 с лишним гигабайта памяти. Итак, определяем класс Octet в котором 
определяем поле с, собственно, массивом, поле boolean full - индикатор, что массив полон, и int fillCounter - счетчик 
заполненности массива. Когда заполняется ячейка в массиве - инкрементируем fillCounter, а когда fillCounter достигает 
значения 256 - выставляем full в true и удаляем массив. Всё вроде бы довольно просто. Давайте посчитаем, сколько будет 
"весить" экземпляр такого класса.

 ```
1-3 уровень
new Octet()
Заголовок: 16 байт
Поле int fillCounter: 4 байта
Поле boolean full: 4 байта
Ссылочная переменная на объект массива: 8 байт
Итого: 32 байта

new Octet[256]
Заголовок: 16 байт + 4 байта на длину массива = 20 байт
Ссылочные переменные на объекты массивов: 8 байт х 256 : 2048 байт
Выравнивание для кратности 8-ми : 4 байт
Итого: 2072 байта

Итого new Octet() = 2072 + 32 = 2104 байта  
  
4-й уровень
new Octet()
Заголовок: 16 байт
Поле int fillCounter: 4 байта
Поле boolean full: 4 байта
Ссылочная переменная на объект массива: 8 байт
Итого: 32 байта

new Octet[256]
Заголовок: 16 байт + 4 байта на длину массива = 20 байт
Ссылочные переменные на объекты массивов: 1 байт х 256 : 256 байт
Выравнивание для кратности 8-ми : 4 байт
Итого: 280 байт

Итого new Octet() = 280 + 32 = 312 байт  
 ```
 
Теперь опять за калькулятор. Максимальное количество памяти для Octet'ов 1-3 уровней у нас в хранилище 
(1 + 256 + 65.536) х 2104 = 138.428.472 байта = 132 мегабайта. И Octet'ы 4-го уровня 16.777.216 х 312 = 5.234.491.392 
байта = 4,875 гигабайта. Итого 138.428.472 + 5.234.491.392 = 5.372.919.864 байт = 5 гигабайт. Учтём также, что "дерево"
скорее всего никогда не "дорастёт" до этих пяти гигабайт, т.к. его ветви будут периодически "схлопываться". 
Если конечно не подавать на вход такому дереву файл в котором пропущены все адреса заканчивающиеся, например на 255. 
В таком случае, все последние массивы заполнятся за исключением 255-й ячейки и схлопывания не произойдет. Отчасти 
это можно предотвратить если в каждом Octet'е разбить один массив с 256 ячейками на, например, 4 массива по 64 
ячейки. Тогда их можно будет и инициализировать только в случае их необходимости, и схлопывать по отдельности. 
Такой алгоритм, как раз и является вторым в данном репозитории. Можно пойти дальше и разбивать массивы вплоть до 
отдельных полей с Octet'ами. Но в этом случае сильно возрастут накладные расходы.

### Итоги
Разумеется, данный алгоритм, скорее всего не самый оптимальный. Пока я его писал, в голову пришло ещё несколько идей.
Думаю можно реализовать похожее дерево, только с корнем не в виде первого октета, а разделить адрес на 2 части по 2 
октета и идти вправо и влево сравнивая половины адреса. В таком случае хранилище станет ещё меньше, но нужно будет 
поработать над алгоритмом. Узнал про существование BitSet. Наверняка можно воспользоваться им, играя отдельными 
битами IP-адреса. Ещё можно представить адрес, как 4 байта и маску со значением 32. Помещать адреса в контейнер, 
который будет их сортировать по сетям и для адресов идущих подряд в одной сети, постепенно уменьшать маску на единицу, 
постепенно доводя её до нуля тем самым схлопывая эти адреса. Наверно самым оптимальным решением данной задачи было
бы реализовать фильтр Блума. Нужно только подобрать правильный размер массива этого фильтра, чтобы туда могли 
"поместиться" все 4 миллиарда адресов (или сделать несколько таких массивов), и подобрать набор хэш-функций, которые 
смогли бы выдать такой хэш-код. В общем, есть что пробовать. Задача оказалась довольно интересной. Получил огромное 
удовольствие решая её.
