# Unique-IP-counter
Данная небольшая программка решает нижеизложенную задачу. Предпологается, что будет 2 варианта алгоритма, с небольшими 
отличиями в "работе с памятью". 

###Задача:
Дан простой текстовый файл с IPv4 адресами. Одна строка – один адрес, примерно так:

```
145.67.23.4
8.34.5.23
89.54.3.124
89.54.3.124
3.45.71.5
...
```
Файл в размере не ограничен и может занимать десятки и сотни гигабайт.

Необходимо посчитать количество уникальных адресов в этом файле, затратив как можно меньше памяти и времени. 
Существует "наивный" алгоритм решения данной задачи (читаем строка за строкой, кладем строки в HashSet), 
желательно чтобы ваша реализация была лучше этого простого, наивного алгоритма.

### Что имеем?
На первый взгляд, задача не очень сложная. Нам нужно завести некий "список". Далее читать из файла строки 
по одной, и сверяться со "списком". Если адреса в списке ещё нет - то добавлять адрес в список. А когда файл 
закончится - просто посчитать в нашем "списке" количество записей. Это и будет ответ. Проблемы начинаются от 
того, что количество уникальных IPv4-адресов равно 256 х 256 х 256 х 256 = 4.294.967.296 штук. Так как 
1 IPv4-адрес это 4 байта, то просто набор байт всех IP-адресов, без точек-разделителей, переносов каретки и пр.
будет занимать 4.294.967.296 х 4 = 17.179.869.184 байта, т.е. 16 гигабайт. А при условии, что файл на входе 
может быть сотни гигабайт - то есть ненулевая вероятность того, что в нём будут все возможные IP-адреса.
И нам, в нашем "списке" для уникальных адресов, в итоге придётся хранить их все. Плюс ко всему, по этому 
"списку" каждый раз нужно будет как-то итерироваться, дабы узнать, есть ли уже там адрес или нет.

### Как же решить такую задачу, затратив как можно меньше памяти и времени? 
Кстати об упомянутом в задаче "наивном" алгоритме решения: Как я понял (возможно я не прав, это теоретические 
рассуждения), называется этот алгоритм "наивным" потому, что должно быть довольно много коллизий, т.к: 
1.  Метод hashCode() у класса String реализован так, что у строк со всеми вариантами IP-адресов, в некоторых 
случаях будут совпадать хэш-коды. Т.к. Произойдет неоднократное переполнение значения примитива int, 
возвращаемого данным методом. Даже если строки будут приходить без точек-разделителей (просто строки с числами). 
Более того, переполнение происходило бы даже если бы hashCode() возвращал long (опять же, даже в случае со 
строками без точек), но уже не так часто, как у int.
2.  К тому же, каждая такая строка с адресом весила бы несравненно больше четырёх байт.
3.  HashSet в java основан на HashMap. А HashMap в свою очередь имеет внутри себя массив Node<K,V>[] table, 
в котором лежат корзины со связанными списками ключей и значений. Так вот, максимальный размер в этой таблице, 
который можно указать при инициализации, равен половине максимально значения типа int, т.е. 1.073.741.824. 
Даже если эта таблица будет увеличиваться в размерах, по мере поступления новых значений, то она все равно не 
превысит максимального значения типа int 2.147.483.647. Т.к. в java максимально допустимый размер у массива 
может быть Integer.MAX_VALUE - 8. А это в 2 раза меньше всех возможных значений IP-адресов.

Ещё один простой 
вариант - завести на диске второй текстовый файл и записывать уникальные адреса в него. Памяти (оперативной) так 
мы на него не тратим, но тогда нам каждый раз нужно будет проходиться по нему поиском, как и говорилось выше.
Значит нужно думать над своим типом хранилища.  

